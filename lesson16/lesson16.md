# Перевіряємо скільки і які шелли встановлені в системі:

```cat /etc/shells```

![Список шеллів в файлі /etc/shells](etc_shells.png)

Якась дичина. Виявляється, деякі файли і каталоги в цьому списку є символічними посиланнями. Що ж, напишемо скрипт, який коректно виведе встановлені в системі шелли:

```bash
#!/bin/bash
for i in $(
  cat /etc/shells | # Зчитуємо файл зі списком шеллів
  grep -P '^[^#]'   # Прибираємо коментарі
  )
do
  # Якщо файл чи каталог, в якому знаходиться цей файл
  # не є символічним посиланням
  if [ ! -L $i ] && [ ! -L $(dirname $i) ]; then
    echo $(basename $i)  # То виводимо на stdout назву шелла
  fi
done |
cat -n # Додаємо номери рядків
```

* Тепер вивід виглядає набагато краще:

![Список шеллів](etc_shells_script.png)

# Поточний шелл можна дізнатися командою `ps`:

![Вивід команди ps](ps.png)

# Вміст змінної $SHELL дізнаємося командою `echo $SHELL`:

![Значення змінної $SHELL](shell_var.png)

# Також поточний шелл можна дізнатися командою readlink:

```readlink /proc/$$/exe```

## `$$` - це змінна, що зберігає PID поточного процесу
## Файл /proc/<PID процесу>/exe є символічним посиланням на файл, з якого процес був запущений
## Команда `readlink` зчитує символічне посилання і повертає цільовий шлях до файлу
* Як бачимо, хоча шелл у нас `/bin/zsh`, команда вивела `/usr/bin/zsh`, оскільки в моїй системі каталог `/bin` є символічним посиланням на `/usr/bin`
![Шлях до поточного шеллу по команді readlink](readlink_proc.png)

# Перевірка поточної версії шелла
Можна скористатись командою `$SHELL --version`, але вона не є універсальною:

![Версія шеллу](shell_version.png)

## Альтернативний варіант

Шелл dash настільки вбогий, що не розуміє опцію `--version`. Тому за потреби доведеться скористатися послугами пакетного менеджера:

![Версія dash](dash.png)

# Змінюємо шелл за замовчуванням на bash

```chsh -s /bin/bash```
![Зміна шеллу за замовчуванням](chsh.png)

* проверить какой текущий шелл проверкой текущих переменных окружения
```echo $BASH```

* попробовать сравнить переменные окружения из tty & ssh сессий
```diff -u <(env|sort) <(ssh localhost env|sort) | tig```
![Різниця змінних середовища в tty і ssh](env_diff.png)

* проверить переменные окружения командой env
```env```
![Вивід команди env](env.png)
